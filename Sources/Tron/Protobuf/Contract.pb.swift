// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/Contract.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

//
// java-tron is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// java-tron is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Protocol_ResourceCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bandwidth // = 0
  case energy // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .bandwidth
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bandwidth
    case 1: self = .energy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bandwidth: return 0
    case .energy: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_ResourceCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_ResourceCode] = [
    .bandwidth,
    .energy,
  ]
}

#endif  // swift(>=4.2)

struct Protocol_AccountCreateContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var accountAddress: Data = SwiftProtobuf.Internal.emptyData

  var type: Protocol_AccountType = .normal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Update account name. Account name is not unique now.
struct Protocol_AccountUpdateContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountName: Data = SwiftProtobuf.Internal.emptyData

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Set account id if the account has no id. Account id is unique and case insensitive.
struct Protocol_SetAccountIdContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: Data = SwiftProtobuf.Internal.emptyData

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_TransferContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var toAddress: Data = SwiftProtobuf.Internal.emptyData

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_TransferAssetContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetName: Data = SwiftProtobuf.Internal.emptyData

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var toAddress: Data = SwiftProtobuf.Internal.emptyData

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_VoteAssetContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var voteAddress: [Data] = []

  var support: Bool = false

  var count: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_VoteWitnessContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var votes: [Protocol_VoteWitnessContract.Vote] = []

  var support: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Vote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var voteAddress: Data = SwiftProtobuf.Internal.emptyData

    var voteCount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Protocol_UpdateSettingContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var contractAddress: Data = SwiftProtobuf.Internal.emptyData

  var consumeUserResourcePercent: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_WitnessCreateContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var url: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_WitnessUpdateContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var updateURL: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_AssetIssueContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  var name: Data {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var abbr: Data {
    get {return _storage._abbr}
    set {_uniqueStorage()._abbr = newValue}
  }

  var totalSupply: Int64 {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  var frozenSupply: [Protocol_AssetIssueContract.FrozenSupply] {
    get {return _storage._frozenSupply}
    set {_uniqueStorage()._frozenSupply = newValue}
  }

  var trxNum: Int32 {
    get {return _storage._trxNum}
    set {_uniqueStorage()._trxNum = newValue}
  }

  var num: Int32 {
    get {return _storage._num}
    set {_uniqueStorage()._num = newValue}
  }

  var startTime: Int64 {
    get {return _storage._startTime}
    set {_uniqueStorage()._startTime = newValue}
  }

  var endTime: Int64 {
    get {return _storage._endTime}
    set {_uniqueStorage()._endTime = newValue}
  }

  /// the order of tokens of the same name
  var order: Int64 {
    get {return _storage._order}
    set {_uniqueStorage()._order = newValue}
  }

  var voteScore: Int32 {
    get {return _storage._voteScore}
    set {_uniqueStorage()._voteScore = newValue}
  }

  var description_p: Data {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var url: Data {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var freeAssetNetLimit: Int64 {
    get {return _storage._freeAssetNetLimit}
    set {_uniqueStorage()._freeAssetNetLimit = newValue}
  }

  var publicFreeAssetNetLimit: Int64 {
    get {return _storage._publicFreeAssetNetLimit}
    set {_uniqueStorage()._publicFreeAssetNetLimit = newValue}
  }

  var publicFreeAssetNetUsage: Int64 {
    get {return _storage._publicFreeAssetNetUsage}
    set {_uniqueStorage()._publicFreeAssetNetUsage = newValue}
  }

  var publicLatestFreeNetTime: Int64 {
    get {return _storage._publicLatestFreeNetTime}
    set {_uniqueStorage()._publicLatestFreeNetTime = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct FrozenSupply {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var frozenAmount: Int64 = 0

    var frozenDays: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_ParticipateAssetIssueContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var toAddress: Data = SwiftProtobuf.Internal.emptyData

  /// the namekey of target asset, include name and order
  var assetName: Data = SwiftProtobuf.Internal.emptyData

  /// the amount of drops
  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_FreezeBalanceContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var frozenBalance: Int64 = 0

  var frozenDuration: Int64 = 0

  var resource: Protocol_ResourceCode = .bandwidth

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_UnfreezeBalanceContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var resource: Protocol_ResourceCode = .bandwidth

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_UnfreezeAssetContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_WithdrawBalanceContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_UpdateAssetContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var description_p: Data = SwiftProtobuf.Internal.emptyData

  var url: Data = SwiftProtobuf.Internal.emptyData

  var newLimit: Int64 = 0

  var newPublicLimit: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ProposalCreateContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var parameters: Dictionary<Int64,Int64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ProposalApproveContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var proposalID: Int64 = 0

  /// add or remove approval
  var isAddApproval: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ProposalDeleteContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var proposalID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_CreateSmartContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  var newContract: Protocol_SmartContract {
    get {return _storage._newContract ?? Protocol_SmartContract()}
    set {_uniqueStorage()._newContract = newValue}
  }
  /// Returns true if `newContract` has been explicitly set.
  var hasNewContract: Bool {return _storage._newContract != nil}
  /// Clears the value of `newContract`. Subsequent reads from it will return its default value.
  mutating func clearNewContract() {_uniqueStorage()._newContract = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_TriggerSmartContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var contractAddress: Data = SwiftProtobuf.Internal.emptyData

  var callValue: Int64 = 0

  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_BuyStorageContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  /// trx quantity for buy storage (sun)
  var quant: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_BuyStorageBytesContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  /// storage bytes for buy
  var bytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_SellStorageContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var storageBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ExchangeCreateContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var firstTokenID: Data = SwiftProtobuf.Internal.emptyData

  var firstTokenBalance: Int64 = 0

  var secondTokenID: Data = SwiftProtobuf.Internal.emptyData

  var secondTokenBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ExchangeInjectContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var exchangeID: Int64 = 0

  var tokenID: Data = SwiftProtobuf.Internal.emptyData

  var quant: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ExchangeWithdrawContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var exchangeID: Int64 = 0

  var tokenID: Data = SwiftProtobuf.Internal.emptyData

  var quant: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ExchangeTransactionContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  var exchangeID: Int64 = 0

  var tokenID: Data = SwiftProtobuf.Internal.emptyData

  var quant: Int64 = 0

  var expected: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_ResourceCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BANDWIDTH"),
    1: .same(proto: "ENERGY"),
  ]
}

extension Protocol_AccountCreateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountCreateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "account_address"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.accountAddress)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.accountAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.accountAddress, fieldNumber: 2)
    }
    if self.type != .normal {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_AccountCreateContract, rhs: Protocol_AccountCreateContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.accountAddress != rhs.accountAddress {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AccountUpdateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountUpdateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .standard(proto: "owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.accountName)
      case 2: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountName.isEmpty {
      try visitor.visitSingularBytesField(value: self.accountName, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_AccountUpdateContract, rhs: Protocol_AccountUpdateContract) -> Bool {
    if lhs.accountName != rhs.accountName {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SetAccountIdContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAccountIdContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.accountID)
      case 2: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.accountID, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_SetAccountIdContract, rhs: Protocol_SetAccountIdContract) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransferContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "to_address"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.toAddress)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TransferContract, rhs: Protocol_TransferContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransferAssetContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferAssetContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_name"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "to_address"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.assetName)
      case 2: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 3: try decoder.decodeSingularBytesField(value: &self.toAddress)
      case 4: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetName.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetName, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TransferAssetContract, rhs: Protocol_TransferAssetContract) -> Bool {
    if lhs.assetName != rhs.assetName {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_VoteAssetContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoteAssetContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "vote_address"),
    3: .same(proto: "support"),
    5: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.voteAddress)
      case 3: try decoder.decodeSingularBoolField(value: &self.support)
      case 5: try decoder.decodeSingularInt32Field(value: &self.count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.voteAddress.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.voteAddress, fieldNumber: 2)
    }
    if self.support != false {
      try visitor.visitSingularBoolField(value: self.support, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_VoteAssetContract, rhs: Protocol_VoteAssetContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.voteAddress != rhs.voteAddress {return false}
    if lhs.support != rhs.support {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_VoteWitnessContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoteWitnessContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "votes"),
    3: .same(proto: "support"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.votes)
      case 3: try decoder.decodeSingularBoolField(value: &self.support)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 2)
    }
    if self.support != false {
      try visitor.visitSingularBoolField(value: self.support, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_VoteWitnessContract, rhs: Protocol_VoteWitnessContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.support != rhs.support {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_VoteWitnessContract.Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_VoteWitnessContract.protoMessageName + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_address"),
    2: .standard(proto: "vote_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.voteAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.voteCount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteAddress, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_VoteWitnessContract.Vote, rhs: Protocol_VoteWitnessContract.Vote) -> Bool {
    if lhs.voteAddress != rhs.voteAddress {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_UpdateSettingContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSettingContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "contract_address"),
    3: .standard(proto: "consume_user_resource_percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.contractAddress)
      case 3: try decoder.decodeSingularInt64Field(value: &self.consumeUserResourcePercent)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractAddress, fieldNumber: 2)
    }
    if self.consumeUserResourcePercent != 0 {
      try visitor.visitSingularInt64Field(value: self.consumeUserResourcePercent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_UpdateSettingContract, rhs: Protocol_UpdateSettingContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.consumeUserResourcePercent != rhs.consumeUserResourcePercent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_WitnessCreateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WitnessCreateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.url)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularBytesField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_WitnessCreateContract, rhs: Protocol_WitnessCreateContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_WitnessUpdateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WitnessUpdateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    12: .standard(proto: "update_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 12: try decoder.decodeSingularBytesField(value: &self.updateURL)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.updateURL.isEmpty {
      try visitor.visitSingularBytesField(value: self.updateURL, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_WitnessUpdateContract, rhs: Protocol_WitnessUpdateContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.updateURL != rhs.updateURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AssetIssueContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetIssueContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "name"),
    3: .same(proto: "abbr"),
    4: .standard(proto: "total_supply"),
    5: .standard(proto: "frozen_supply"),
    6: .standard(proto: "trx_num"),
    8: .same(proto: "num"),
    9: .standard(proto: "start_time"),
    10: .standard(proto: "end_time"),
    11: .same(proto: "order"),
    16: .standard(proto: "vote_score"),
    20: .same(proto: "description"),
    21: .same(proto: "url"),
    22: .standard(proto: "free_asset_net_limit"),
    23: .standard(proto: "public_free_asset_net_limit"),
    24: .standard(proto: "public_free_asset_net_usage"),
    25: .standard(proto: "public_latest_free_net_time"),
  ]

  fileprivate class _StorageClass {
    var _ownerAddress: Data = SwiftProtobuf.Internal.emptyData
    var _name: Data = SwiftProtobuf.Internal.emptyData
    var _abbr: Data = SwiftProtobuf.Internal.emptyData
    var _totalSupply: Int64 = 0
    var _frozenSupply: [Protocol_AssetIssueContract.FrozenSupply] = []
    var _trxNum: Int32 = 0
    var _num: Int32 = 0
    var _startTime: Int64 = 0
    var _endTime: Int64 = 0
    var _order: Int64 = 0
    var _voteScore: Int32 = 0
    var _description_p: Data = SwiftProtobuf.Internal.emptyData
    var _url: Data = SwiftProtobuf.Internal.emptyData
    var _freeAssetNetLimit: Int64 = 0
    var _publicFreeAssetNetLimit: Int64 = 0
    var _publicFreeAssetNetUsage: Int64 = 0
    var _publicLatestFreeNetTime: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ownerAddress = source._ownerAddress
      _name = source._name
      _abbr = source._abbr
      _totalSupply = source._totalSupply
      _frozenSupply = source._frozenSupply
      _trxNum = source._trxNum
      _num = source._num
      _startTime = source._startTime
      _endTime = source._endTime
      _order = source._order
      _voteScore = source._voteScore
      _description_p = source._description_p
      _url = source._url
      _freeAssetNetLimit = source._freeAssetNetLimit
      _publicFreeAssetNetLimit = source._publicFreeAssetNetLimit
      _publicFreeAssetNetUsage = source._publicFreeAssetNetUsage
      _publicLatestFreeNetTime = source._publicLatestFreeNetTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._ownerAddress)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._name)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._abbr)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._totalSupply)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._frozenSupply)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._trxNum)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._num)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._startTime)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._endTime)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._order)
        case 16: try decoder.decodeSingularInt32Field(value: &_storage._voteScore)
        case 20: try decoder.decodeSingularBytesField(value: &_storage._description_p)
        case 21: try decoder.decodeSingularBytesField(value: &_storage._url)
        case 22: try decoder.decodeSingularInt64Field(value: &_storage._freeAssetNetLimit)
        case 23: try decoder.decodeSingularInt64Field(value: &_storage._publicFreeAssetNetLimit)
        case 24: try decoder.decodeSingularInt64Field(value: &_storage._publicFreeAssetNetUsage)
        case 25: try decoder.decodeSingularInt64Field(value: &_storage._publicLatestFreeNetTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ownerAddress, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._abbr.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._abbr, fieldNumber: 3)
      }
      if _storage._totalSupply != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSupply, fieldNumber: 4)
      }
      if !_storage._frozenSupply.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozenSupply, fieldNumber: 5)
      }
      if _storage._trxNum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._trxNum, fieldNumber: 6)
      }
      if _storage._num != 0 {
        try visitor.visitSingularInt32Field(value: _storage._num, fieldNumber: 8)
      }
      if _storage._startTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startTime, fieldNumber: 9)
      }
      if _storage._endTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._endTime, fieldNumber: 10)
      }
      if _storage._order != 0 {
        try visitor.visitSingularInt64Field(value: _storage._order, fieldNumber: 11)
      }
      if _storage._voteScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._voteScore, fieldNumber: 16)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._description_p, fieldNumber: 20)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._url, fieldNumber: 21)
      }
      if _storage._freeAssetNetLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._freeAssetNetLimit, fieldNumber: 22)
      }
      if _storage._publicFreeAssetNetLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._publicFreeAssetNetLimit, fieldNumber: 23)
      }
      if _storage._publicFreeAssetNetUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._publicFreeAssetNetUsage, fieldNumber: 24)
      }
      if _storage._publicLatestFreeNetTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._publicLatestFreeNetTime, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_AssetIssueContract, rhs: Protocol_AssetIssueContract) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._abbr != rhs_storage._abbr {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._frozenSupply != rhs_storage._frozenSupply {return false}
        if _storage._trxNum != rhs_storage._trxNum {return false}
        if _storage._num != rhs_storage._num {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._order != rhs_storage._order {return false}
        if _storage._voteScore != rhs_storage._voteScore {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._freeAssetNetLimit != rhs_storage._freeAssetNetLimit {return false}
        if _storage._publicFreeAssetNetLimit != rhs_storage._publicFreeAssetNetLimit {return false}
        if _storage._publicFreeAssetNetUsage != rhs_storage._publicFreeAssetNetUsage {return false}
        if _storage._publicLatestFreeNetTime != rhs_storage._publicLatestFreeNetTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AssetIssueContract.FrozenSupply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_AssetIssueContract.protoMessageName + ".FrozenSupply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frozen_amount"),
    2: .standard(proto: "frozen_days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.frozenAmount)
      case 2: try decoder.decodeSingularInt64Field(value: &self.frozenDays)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frozenAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenAmount, fieldNumber: 1)
    }
    if self.frozenDays != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenDays, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_AssetIssueContract.FrozenSupply, rhs: Protocol_AssetIssueContract.FrozenSupply) -> Bool {
    if lhs.frozenAmount != rhs.frozenAmount {return false}
    if lhs.frozenDays != rhs.frozenDays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ParticipateAssetIssueContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipateAssetIssueContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "to_address"),
    3: .standard(proto: "asset_name"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.toAddress)
      case 3: try decoder.decodeSingularBytesField(value: &self.assetName)
      case 4: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.assetName.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetName, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ParticipateAssetIssueContract, rhs: Protocol_ParticipateAssetIssueContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.assetName != rhs.assetName {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_FreezeBalanceContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreezeBalanceContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "frozen_balance"),
    3: .standard(proto: "frozen_duration"),
    10: .same(proto: "resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.frozenBalance)
      case 3: try decoder.decodeSingularInt64Field(value: &self.frozenDuration)
      case 10: try decoder.decodeSingularEnumField(value: &self.resource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.frozenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalance, fieldNumber: 2)
    }
    if self.frozenDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenDuration, fieldNumber: 3)
    }
    if self.resource != .bandwidth {
      try visitor.visitSingularEnumField(value: self.resource, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_FreezeBalanceContract, rhs: Protocol_FreezeBalanceContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.frozenBalance != rhs.frozenBalance {return false}
    if lhs.frozenDuration != rhs.frozenDuration {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_UnfreezeBalanceContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnfreezeBalanceContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    10: .same(proto: "resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 10: try decoder.decodeSingularEnumField(value: &self.resource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.resource != .bandwidth {
      try visitor.visitSingularEnumField(value: self.resource, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_UnfreezeBalanceContract, rhs: Protocol_UnfreezeBalanceContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_UnfreezeAssetContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnfreezeAssetContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_UnfreezeAssetContract, rhs: Protocol_UnfreezeAssetContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_WithdrawBalanceContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawBalanceContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_WithdrawBalanceContract, rhs: Protocol_WithdrawBalanceContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_UpdateAssetContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAssetContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "description"),
    3: .same(proto: "url"),
    4: .standard(proto: "new_limit"),
    5: .standard(proto: "new_public_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.description_p)
      case 3: try decoder.decodeSingularBytesField(value: &self.url)
      case 4: try decoder.decodeSingularInt64Field(value: &self.newLimit)
      case 5: try decoder.decodeSingularInt64Field(value: &self.newPublicLimit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.description_p, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularBytesField(value: self.url, fieldNumber: 3)
    }
    if self.newLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.newLimit, fieldNumber: 4)
    }
    if self.newPublicLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.newPublicLimit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_UpdateAssetContract, rhs: Protocol_UpdateAssetContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.url != rhs.url {return false}
    if lhs.newLimit != rhs.newLimit {return false}
    if lhs.newPublicLimit != rhs.newPublicLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ProposalCreateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalCreateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: &self.parameters)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ProposalCreateContract, rhs: Protocol_ProposalCreateContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ProposalApproveContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalApproveContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "proposal_id"),
    3: .standard(proto: "is_add_approval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      case 3: try decoder.decodeSingularBoolField(value: &self.isAddApproval)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 2)
    }
    if self.isAddApproval != false {
      try visitor.visitSingularBoolField(value: self.isAddApproval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ProposalApproveContract, rhs: Protocol_ProposalApproveContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.isAddApproval != rhs.isAddApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ProposalDeleteContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalDeleteContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "proposal_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ProposalDeleteContract, rhs: Protocol_ProposalDeleteContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_CreateSmartContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSmartContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "new_contract"),
  ]

  fileprivate class _StorageClass {
    var _ownerAddress: Data = SwiftProtobuf.Internal.emptyData
    var _newContract: Protocol_SmartContract? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ownerAddress = source._ownerAddress
      _newContract = source._newContract
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._ownerAddress)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._newContract)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ownerAddress, fieldNumber: 1)
      }
      if let v = _storage._newContract {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_CreateSmartContract, rhs: Protocol_CreateSmartContract) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        if _storage._newContract != rhs_storage._newContract {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TriggerSmartContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerSmartContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "contract_address"),
    3: .standard(proto: "call_value"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.contractAddress)
      case 3: try decoder.decodeSingularInt64Field(value: &self.callValue)
      case 4: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractAddress, fieldNumber: 2)
    }
    if self.callValue != 0 {
      try visitor.visitSingularInt64Field(value: self.callValue, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TriggerSmartContract, rhs: Protocol_TriggerSmartContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.callValue != rhs.callValue {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BuyStorageContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuyStorageContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "quant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.quant)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.quant != 0 {
      try visitor.visitSingularInt64Field(value: self.quant, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BuyStorageContract, rhs: Protocol_BuyStorageContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.quant != rhs.quant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BuyStorageBytesContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuyStorageBytesContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.bytes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BuyStorageBytesContract, rhs: Protocol_BuyStorageBytesContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SellStorageContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SellStorageContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "storage_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.storageBytes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.storageBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.storageBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_SellStorageContract, rhs: Protocol_SellStorageContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.storageBytes != rhs.storageBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ExchangeCreateContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeCreateContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "first_token_id"),
    3: .standard(proto: "first_token_balance"),
    4: .standard(proto: "second_token_id"),
    5: .standard(proto: "second_token_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.firstTokenID)
      case 3: try decoder.decodeSingularInt64Field(value: &self.firstTokenBalance)
      case 4: try decoder.decodeSingularBytesField(value: &self.secondTokenID)
      case 5: try decoder.decodeSingularInt64Field(value: &self.secondTokenBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.firstTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.firstTokenID, fieldNumber: 2)
    }
    if self.firstTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.firstTokenBalance, fieldNumber: 3)
    }
    if !self.secondTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.secondTokenID, fieldNumber: 4)
    }
    if self.secondTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.secondTokenBalance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ExchangeCreateContract, rhs: Protocol_ExchangeCreateContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.firstTokenID != rhs.firstTokenID {return false}
    if lhs.firstTokenBalance != rhs.firstTokenBalance {return false}
    if lhs.secondTokenID != rhs.secondTokenID {return false}
    if lhs.secondTokenBalance != rhs.secondTokenBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ExchangeInjectContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeInjectContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "exchange_id"),
    3: .standard(proto: "token_id"),
    4: .same(proto: "quant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.exchangeID)
      case 3: try decoder.decodeSingularBytesField(value: &self.tokenID)
      case 4: try decoder.decodeSingularInt64Field(value: &self.quant)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 3)
    }
    if self.quant != 0 {
      try visitor.visitSingularInt64Field(value: self.quant, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ExchangeInjectContract, rhs: Protocol_ExchangeInjectContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.quant != rhs.quant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ExchangeWithdrawContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeWithdrawContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "exchange_id"),
    3: .standard(proto: "token_id"),
    4: .same(proto: "quant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.exchangeID)
      case 3: try decoder.decodeSingularBytesField(value: &self.tokenID)
      case 4: try decoder.decodeSingularInt64Field(value: &self.quant)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 3)
    }
    if self.quant != 0 {
      try visitor.visitSingularInt64Field(value: self.quant, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ExchangeWithdrawContract, rhs: Protocol_ExchangeWithdrawContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.quant != rhs.quant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ExchangeTransactionContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeTransactionContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "exchange_id"),
    3: .standard(proto: "token_id"),
    4: .same(proto: "quant"),
    5: .same(proto: "expected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.exchangeID)
      case 3: try decoder.decodeSingularBytesField(value: &self.tokenID)
      case 4: try decoder.decodeSingularInt64Field(value: &self.quant)
      case 5: try decoder.decodeSingularInt64Field(value: &self.expected)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 3)
    }
    if self.quant != 0 {
      try visitor.visitSingularInt64Field(value: self.quant, fieldNumber: 4)
    }
    if self.expected != 0 {
      try visitor.visitSingularInt64Field(value: self.expected, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ExchangeTransactionContract, rhs: Protocol_ExchangeTransactionContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.quant != rhs.quant {return false}
    if lhs.expected != rhs.expected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
